-- Question 1 : Écrire une requête qui affiche tous les couples (employee,manager) où 
-- manager est l’identifiant d’un chef direct ou indirect de l’employé d’identifiant employee

-- Solution :

    with recursive employ_manag(employee_id, manager_id) as (
      select employee_id, manager_id from employees where manager_id is not null
      union
      select e.employee_id, employ_manag.manager_id from employees as e, employ_manag where e.manager_id = employ_manag.employee_id
    )
    select * from employ_manag order by employee_id;
    
    
-- Question 2 : Ecrire une requête qui affiche tous les couples (employee, manager) où 
-- manager est le nom d’un chef direct ou indirect de l’employé de nom employee.

-- Solution :

WITH RECURSIVE employ_manag(employee_id, manager_id) AS
                   (
                       SELECT employee_id, manager_id
                       FROM employees as e
                       WHERE e.manager_id is not null
                       UNION
                       SELECT e.employee_id, em.manager_id
                       FROM employees as e,
                            employ_manag as em
                       WHERE e.manager_id = em.employee_id
                   )
select e.last_name, e2.last_name
from employees AS e
         JOIN employ_manag as emp
              on e.employee_id = emp.employee_id
         JOIN employees as e2 on e2.employee_id = emp.manager_id
order by e.last_name;


-- Question 3 : Écrire une requête qui affiche tous les triplets (employee, manager, distance) où 
-- manager est le nom d’un chef direct ou indirect de l’employé de nom employee et 
-- distance est la distance hiérarchique entre les deux (1 pour un chef direct, 2 pour le chef direct du chef direct, etc.).

-- Solution :

WITH RECURSIVE employ_manag(employee_id, manager_id, distance) AS
                   (
                       SELECT employee_id, manager_id, 1
                       FROM employees as e
                       WHERE e.manager_id is not null
                       UNION
                       SELECT e.employee_id, em.manager_id, em.distance + 1
                       FROM employees as e,
                            employ_manag as em
                       WHERE e.manager_id = em.employee_id
                   )
select e.last_name, e2.last_name, emp.distance
from employees AS e
         JOIN employ_manag as emp
              on e.employee_id = emp.employee_id
         JOIN employees as e2 on e2.employee_id = emp.manager_id
order by e.last_name;

-- Question 4 : Écrire une requête qui affiche pour tous les employés leur identifiant, leur nom, leur distance au PDG, 
-- le nom de tous leurs chefs directs ou indirects, les identifiants de tous leurs chefs directs ou indirects.

-- Solution : Je n'ai pas utilisé la fonction STRING_AGG, mais plutôt la concaténation native du SQL



ATTENTION SOLUTION DE MERDE ICI - CORRECTION A VENIR !!!!!!!!!!!!!



WITH RECURSIVE employ_manag(employee_id, manager_id, distance, noms_chefs, ids_chefs) AS
                   (
                       SELECT e.employee_id,
                              e.manager_id,
                              1,
                              CAST(e2.last_name as varchar),
                              CAST(e.manager_id as varchar)
                       FROM employees as e
                                join employees as e2 on e.manager_id = e2.employee_id
                       WHERE e.manager_id is not null
                       UNION
                       SELECT e.employee_id,
                              em.manager_id,
                              em.distance + 1,
                              e2.last_name || ' - ' || em.noms_chefs,
                              CAST(e2.employee_id as varchar) || ' | ' || ids_chefs
                       FROM employees as e,
                            employ_manag as em
                                join employees as e2 on em.employee_id = e2.employee_id
                       WHERE e.manager_id = em.employee_id
                   )


select e.employee_id, e.last_name, emp.distance as niveau, emp.noms_chefs, emp.ids_chefs
from employees AS e
         JOIN employ_manag as emp
              on e.employee_id = emp.employee_id
         JOIN employees as e2 on e2.employee_id = emp.manager_id
        WHERE e2.last_name LIKE 'King'
order by emp.distance desc;




--------------------------------------------------------- EXERCICE 2 -----------------------------------------------------------------------

-- Question 1 :

SELECT r.region_name, c.country_name, l.city, COUNT(DISTINCT d.department_id), COUNT(*)
FROM regions as r
         JOIN countries c on r.region_id = c.region_id
         JOIN locations l on c.country_id = l.country_id
         JOIN departments d on l.location_id = d.location_id
         JOIN employees e on d.department_id = e.department_id
GROUP BY r.region_name, c.country_name, l.city;


-- Question 2 :

SELECT r.region_name, c.country_name, l.city, COUNT(DISTINCT d.department_id), COUNT(*)
FROM regions as r
         JOIN countries c on r.region_id = c.region_id
         JOIN locations l on c.country_id = l.country_id
         JOIN departments d on l.location_id = d.location_id
         JOIN employees e on d.department_id = e.department_id
GROUP BY
    GROUPING SETS ( (r.region_name, c.country_name, l.city),
                    (r.region_name, c.country_name),
                    (r.region_name),
                    ()
    );

-- Question 3 :

SELECT COALESCE(r.region_name, 'Toutes les regions'), COALESCE(c.country_name, 'Tous les pays'), COALESCE(l.city, 'Toutes les villes'), COUNT(DISTINCT d.department_id), COUNT(*)
FROM regions as r
         JOIN countries c on r.region_id = c.region_id
         JOIN locations l on c.country_id = l.country_id
         JOIN departments d on l.location_id = d.location_id
         JOIN employees e on d.department_id = e.department_id
GROUP BY
    GROUPING SETS ( (r.region_name, c.country_name, l.city),
                    (r.region_name, c.country_name),
                    (r.region_name),
                    ()
    );
